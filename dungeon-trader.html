<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dungeon Trader - C64 Style</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0000AA;
            color: #AAAAFF;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px 10px;
        }
        .container {
            width: 100%;
            max-width: 800px;
            background: #0000AA;
            border: 4px solid #AAAAFF;
            padding: 15px;
            margin: 0 auto;
        }
        .title {
            text-align: center;
            color: #FFFFFF;
            font-size: clamp(18px, 5vw, 24px);
            margin-bottom: 15px;
        }
        .game-view {
            background: #000000;
            border: 2px solid #AAAAFF;
            margin-bottom: 20px;
            position: relative;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: auto;
            max-height: 50vh;
            min-height: 300px;
        }
        .stats-panel {
            background: #000055;
            border: 2px solid #AAAAFF;
            padding: 15px;
            margin-bottom: 20px;
        }
        .stat-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 6px;
            font-size: 13px;
        }
        .stat-label { color: #FFFF55; }
        .stat-value { color: #FFFFFF; text-align: right; }
        .message-box {
            background: #000000;
            border: 2px solid #AAAAFF;
            padding: 12px;
            margin-bottom: 15px;
            min-height: 60px;
            color: #FFFFFF;
            font-size: 13px;
            line-height: 1.5;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .btn {
            background: #000055;
            border: 2px solid #AAAAFF;
            color: #FFFFFF;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            cursor: pointer;
            text-transform: uppercase;
            white-space: nowrap;
        }
        .btn:hover { background: #0000FF; color: #FFFF55; }
        .btn:disabled { background: #000033; color: #555555; cursor: not-allowed; }
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .trading-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #0000AA;
            border: 4px solid #FFFF55;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            display: none;
            z-index: 1000;
        }
        .trading-menu.active { display: block; }
        .trading-header {
            color: #FFFF55;
            font-size: 18px;
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #FFFF55;
        }
        .item-list { margin-bottom: 15px; }
        .item-row {
            background: #000055;
            border: 2px solid #AAAAFF;
            padding: 12px;
            margin-bottom: 10px;
        }
        .item-name { color: #FFFF55; font-size: 14px; margin-bottom: 5px; }
        .item-info { color: #AAAAFF; font-size: 12px; margin-bottom: 8px; }
        .item-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .victory-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #0000AA;
            border: 4px solid #FFFF55;
            padding: 40px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        .victory-screen.active { display: block; }
        .victory-title { color: #FFFF55; font-size: 32px; margin-bottom: 20px; }
        .victory-text { color: #FFFFFF; font-size: 16px; margin-bottom: 20px; }
        .minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 85, 0.8);
            border: 2px solid #AAAAFF;
        }
    
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            body { padding: 10px 5px; }
            .container { padding: 10px; border-width: 2px; }
            .title { font-size: 18px; margin-bottom: 10px; }
            .stat-row { font-size: 11px; gap: 8px; }
            .message-box { font-size: 12px; padding: 10px; min-height: 50px; }
            .btn { font-size: 11px; padding: 10px; }
            #gameCanvas { min-height: 250px; }
            .controls { gap: 8px; }
            .action-buttons { gap: 8px; }
        }
        
        @media (max-width: 480px) {
            .container { padding: 8px; }
            .title { font-size: 16px; }
            .stat-row { font-size: 10px; }
            .message-box { font-size: 11px; }
            .btn { font-size: 10px; padding: 8px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">‚öî DUNGEON TRADER ‚öî</div>
        
        <div class="game-view">
            <canvas id="gameCanvas" width="800" height="400"></canvas>
            <canvas id="minimap" class="minimap" width="120" height="120"></canvas>
        </div>

        <div class="stats-panel">
            <div class="stat-row">
                <div><span class="stat-label">LEVEL:</span></div>
                <div class="stat-value" id="dungeonLevel">1</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">HEALTH:</span></div>
                <div class="stat-value"><span id="healthAmount">100</span>/100</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">ATTACK:</span></div>
                <div class="stat-value" id="attackAmount">5</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">DEFENSE:</span></div>
                <div class="stat-value" id="defenseAmount">0</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">GOLD:</span></div>
                <div class="stat-value" id="goldAmount">50</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">BREAD:</span></div>
                <div class="stat-value" id="breadCount">2</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">IRON ORE:</span></div>
                <div class="stat-value" id="oreCount">0</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">GEMS:</span></div>
                <div class="stat-value" id="gemsCount">0</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">HERBS:</span></div>
                <div class="stat-value" id="herbsCount">0</div>
            </div>
            <div class="stat-row">
                <div><span class="stat-label">ESCAPE KEY:</span></div>
                <div class="stat-value" id="keyStatus">NO</div>
            </div>
        </div>

        <div class="message-box" id="messageBox">
            *** DUNGEON TRADER - 3 LEVELS ***<br><br>
            GOAL: EARN 500 GOLD TO BUY THE ESCAPE KEY!<br><br>
            1. EXPLORE AND FIND 5 MERCHANTS<br>
            2. BUY ITEMS WHERE CHEAP<br>
            3. SELL WHERE EXPENSIVE<br>
            4. BEWARE THE BAT - IT HUNTS YOU!<br><br>
            ARROW KEYS = MOVE | E = INTERACT
        </div>

        <div class="controls">
            <button class="btn" onclick="turnLeft()">‚Üê TURN LEFT</button>
            <button class="btn" onclick="moveForward()">‚Üë FORWARD</button>
            <button class="btn" onclick="turnRight()">TURN RIGHT ‚Üí</button>
            <button class="btn" style="visibility: hidden;"></button>
            <button class="btn" onclick="moveBackward()">‚Üì BACKWARD</button>
            <button class="btn" style="visibility: hidden;"></button>
        </div>

        <div class="action-buttons">
            <button class="btn" onclick="interact()">INTERACT</button>
            <button class="btn" onclick="rest()">REST</button>
        </div>
    </div>

    <div class="trading-menu" id="tradingMenu">
        <div class="trading-header" id="merchantTitle">MERCHANT</div>
        <div id="merchantSubtitle" style="color: #AAAAFF; text-align: center; margin-bottom: 15px;"></div>
        <div class="item-list" id="itemList"></div>
        <button class="btn" onclick="closeTrade()">CLOSE</button>
    </div>

    <div class="victory-screen" id="victoryScreen">
        <div class="victory-title">*** VICTORY ***</div>
        <div class="victory-text">
            YOU ESCAPED THE DUNGEON!<br><br>
            FINAL GOLD: <span id="finalGold"></span><br><br>
            YOU MASTERED SUPPLY AND DEMAND!<br><br>
            YOU LEARNED TO:<br>
            - BUY LOW WHERE GOODS ARE ABUNDANT<br>
            - SELL HIGH WHERE GOODS ARE SCARCE<br>
            - MAXIMIZE PROFIT THROUGH SMART TRADING<br><br>
            CONGRATULATIONS, MASTER TRADER!
        </div>
        <button class="btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <script>
        const game = {
            gold: 50,
            inventory: { bread: 2, ore: 0, gems: 0, herbs: 0 },
            hasKey: false,
            gameWon: false,
            player: { x: 1, z: 1, dir: 0, health: 100, maxHealth: 100, attack: 5, defense: 0 },
            currentLevel: 1,
            upgrades: { weapon: 0, armor: 0 }
        };

        const MAP_SIZE = 13;
        const CELL_ROOM = 0;
        const CELL_WALL = 1;
        const CELL_MERCHANT = 2;
        const CELL_DOOR = 3;
        const CELL_STAIRS_DOWN = 5;
        const CELL_STAIRS_UP = 6;

        // 3 DUNGEON LEVELS!
        const dungeonLevels = {
            1: {
                map: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,2,0,0,1,0,2,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,1,1,0,1,1,1,0,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,2,0,0,1,0,2,0,0,0,5,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,0,1,1,1],
                    [1,0,0,2,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                bats: [
                    { x: 5, z: 6, dir: 0, moveTimer: 0, attacking: false, health: 20, maxHealth: 20 }
                ]
            },
            2: {
                map: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,6,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,0,1,1,0,1,1,0,1,0,1],
                    [1,0,1,2,1,0,0,2,0,0,1,5,1],
                    [1,0,1,0,0,0,1,1,0,1,1,0,1],
                    [1,0,1,1,1,0,0,0,0,0,1,0,1],
                    [1,0,0,0,0,0,1,0,1,0,0,0,1],
                    [1,0,1,0,1,0,0,0,0,0,1,0,1],
                    [1,0,1,2,1,1,1,0,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                bats: [
                    { x: 7, z: 5, dir: 0, moveTimer: 0, attacking: false, health: 30, maxHealth: 30 },
                    { x: 3, z: 9, dir: 0, moveTimer: 0, attacking: false, health: 30, maxHealth: 30 }
                ]
            },
            3: {
                map: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,6,0,0,0,1,0,0,0,0,0,3,1],
                    [1,0,2,0,0,1,0,2,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,1,1,0,1,1,1,0,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,2,0,0,1,0,2,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,0,1,1,1],
                    [1,0,0,2,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                bats: [
                    { x: 5, z: 6, dir: 0, moveTimer: 0, attacking: false, health: 40, maxHealth: 40 },
                    { x: 9, z: 3, dir: 0, moveTimer: 0, attacking: false, health: 40, maxHealth: 40 },
                    { x: 3, z: 9, dir: 0, moveTimer: 0, attacking: false, health: 40, maxHealth: 40 }
                ]
            }
        };
        
        // Helper functions for current level
        function getCurrentMap() {
            return dungeonLevels[game.currentLevel].map;
        }
        
        function getCurrentBats() {
            return dungeonLevels[game.currentLevel].bats;
        }
        
        // Keep these for backwards compatibility
        const map = dungeonLevels[1].map;
        const bats = dungeonLevels[1].bats;

        const merchants = [
            // LEVEL 1 MERCHANTS
            { x: 2, z: 2, room: 0, level: 1, name: 'GRUFF MINER',
              prices: {
                bread: { buy: 25, sell: 20, reason: 'HIGH DEMAND - MINERS NEED FOOD!' },
                ore: { buy: 8, sell: 5, reason: 'ABUNDANT SUPPLY HERE' },
                gems: { buy: 80, sell: 60, reason: 'STANDARD PRICE' },
                herbs: { buy: 45, sell: 35, reason: 'SCARCE IN CAVES' }
              }
            },
            { x: 7, z: 2, room: 1, level: 1, name: 'HERB GATHERER',
              prices: {
                bread: { buy: 12, sell: 8, reason: 'FAIR MARKET VALUE' },
                ore: { buy: 30, sell: 25, reason: 'HIGH DEMAND - NO MINES!' },
                gems: { buy: 90, sell: 70, reason: 'RARE IN FOREST' },
                herbs: { buy: 10, sell: 5, reason: 'PLENTIFUL HERE' }
              }
            },
            { x: 2, z: 8, room: 2, level: 1, name: 'GEM DEALER',
              prices: {
                bread: { buy: 15, sell: 10, reason: 'AVERAGE DEMAND' },
                ore: { buy: 18, sell: 12, reason: 'AVERAGE DEMAND' },
                gems: { buy: 50, sell: 40, reason: 'HIGH SUPPLY - GEM CENTRAL!' },
                herbs: { buy: 60, sell: 50, reason: 'POPULAR WITH WEALTHY' }
              }
            },
            { x: 7, z: 8, room: 3, level: 1, name: 'DESPERATE TRADER',
              prices: {
                bread: { buy: 30, sell: 25, reason: 'CRITICAL NEED!' },
                ore: { buy: 25, sell: 20, reason: 'NEEDS TOOLS' },
                gems: { buy: 100, sell: 85, reason: 'WILL PAY PREMIUM!' },
                herbs: { buy: 55, sell: 45, reason: 'MEDICAL EMERGENCY' }
              }
            },
            { x: 3, z: 11, room: 11, level: 1, name: 'HEALER',
              prices: {
                bread: { buy: 15, sell: 10, reason: 'STANDARD RATE' },
                ore: { buy: 20, sell: 15, reason: 'STANDARD RATE' },
                gems: { buy: 75, sell: 65, reason: 'STANDARD RATE' },
                herbs: { buy: 40, sell: 30, reason: 'STANDARD RATE' }
              },
              healsFor: 20,
              healCost: 30
            },
            
            // LEVEL 2 MERCHANTS - BLACKSMITH + TRADERS
            { x: 3, z: 5, room: 5, level: 2, name: 'BLACKSMITH', isBlacksmith: true,
              upgrades: {
                'IRON SWORD': { cost: 100, type: 'weapon', level: 1, attack: 3, desc: '+3 ATTACK' },
                'STEEL SWORD': { cost: 300, type: 'weapon', level: 2, attack: 7, desc: '+7 ATTACK' },
                'LEGENDARY BLADE': { cost: 800, type: 'weapon', level: 3, attack: 12, desc: '+12 ATTACK' },
                'IRON ARMOR': { cost: 80, type: 'armor', level: 1, defense: 2, desc: '+2 DEFENSE' },
                'STEEL ARMOR': { cost: 250, type: 'armor', level: 2, defense: 5, desc: '+5 DEFENSE' },
                'LEGENDARY PLATE': { cost: 700, type: 'armor', level: 3, defense: 10, desc: '+10 DEFENSE' }
              }
            },
            { x: 7, z: 5, room: 6, level: 2, name: 'DEEP TRADER',
              prices: {
                bread: { buy: 35, sell: 28, reason: 'HIGH DEMAND UNDERGROUND!' },
                ore: { buy: 40, sell: 32, reason: 'PREMIUM PRICE!' },
                gems: { buy: 120, sell: 100, reason: 'RARE DOWN HERE!' },
                herbs: { buy: 70, sell: 58, reason: 'CRITICAL NEED!' }
              }
            },
            { x: 3, z: 10, room: 7, level: 2, name: 'CAVE MERCHANT',
              prices: {
                bread: { buy: 32, sell: 26, reason: 'DEEPER = COSTLIER!' },
                ore: { buy: 38, sell: 30, reason: 'BETTER PRICE!' },
                gems: { buy: 110, sell: 92, reason: 'VALUABLE HERE!' },
                herbs: { buy: 65, sell: 54, reason: 'NEEDED FOR SURVIVAL!' }
              }
            },
            
            // LEVEL 3 MERCHANTS - BEST PRICES!
            { x: 2, z: 2, room: 8, level: 3, name: 'ANCIENT MERCHANT',
              prices: {
                bread: { buy: 45, sell: 38, reason: 'HIGHEST DEMAND!' },
                ore: { buy: 55, sell: 48, reason: 'BEST PRICE!' },
                gems: { buy: 150, sell: 135, reason: 'MAXIMUM VALUE!' },
                herbs: { buy: 90, sell: 78, reason: 'DESPERATE NEED!' }
              }
            },
            { x: 7, z: 2, room: 9, level: 3, name: 'FINAL TRADER',
              prices: {
                bread: { buy: 48, sell: 40, reason: 'FINAL OFFER!' },
                ore: { buy: 58, sell: 50, reason: 'ULTIMATE PRICE!' },
                gems: { buy: 160, sell: 145, reason: 'LEGENDARY VALUE!' },
                herbs: { buy: 95, sell: 82, reason: 'LIFE OR DEATH!' }
              }
            },
            { x: 2, z: 8, room: 10, level: 3, name: 'ESCAPE MERCHANT',
              prices: {
                bread: { buy: 50, sell: 42, reason: 'LAST CHANCE!' },
                ore: { buy: 60, sell: 52, reason: 'FINAL SALE!' },
                gems: { buy: 170, sell: 155, reason: 'ESCAPE PREMIUM!' },
                herbs: { buy: 100, sell: 85, reason: 'FINAL HEALING!' }
              },
              sellsKey: true,
              keyPrice: 500
            },
            { x: 7, z: 8, room: 4, level: 3, name: 'GATEKEEPER',
              prices: {
                bread: { buy: 40, sell: 35, reason: 'GUARD RATE' },
                ore: { buy: 50, sell: 45, reason: 'GUARD RATE' },
                gems: { buy: 140, sell: 125, reason: 'GUARD RATE' },
                herbs: { buy: 85, sell: 75, reason: 'GUARD RATE' }
              }
            },
            { x: 3, z: 11, room: 12, level: 3, name: 'EXIT HEALER',
              prices: {
                bread: { buy: 35, sell: 30, reason: 'LAST STOP' },
                ore: { buy: 45, sell: 40, reason: 'LAST STOP' },
                gems: { buy: 130, sell: 115, reason: 'LAST STOP' },
                herbs: { buy: 80, sell: 70, reason: 'LAST STOP' }
              },
              healsFor: 30,
              healCost: 50
            }
        ];

        // Bats are now loaded from dungeonLevels[currentLevel].bats
        // const bats = [
        //     { x: 5, z: 6, dir: 0, moveTimer: 0, attacking: false }
        // ];

        const roomColors = {
            0: { wall: '#8B4513', floor: '#654321', name: 'MINING CAVERN' },
            1: { wall: '#228B22', floor: '#1a5c1a', name: 'FOREST OUTPOST' },
            2: { wall: '#4B0082', floor: '#2d004f', name: 'UNDERGROUND MARKET' },
            3: { wall: '#8B0000', floor: '#5c0000', name: 'ABANDONED CAMP' },
            4: { wall: '#FFD700', floor: '#b8860b', name: 'EXIT CHAMBER' }
        };

        const itemNames = {
            bread: 'BREAD',
            ore: 'IRON ORE',
            gems: 'GEMS',
            herbs: 'HEALING HERBS'
        };

        let currentMerchant = null;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        function setMessage(msg) {
            document.getElementById('messageBox').innerHTML = msg;
        }

        function updateUI() {
            document.getElementById('dungeonLevel').textContent = game.currentLevel;
            document.getElementById('healthAmount').textContent = game.player.health;
            document.getElementById('attackAmount').textContent = game.player.attack;
            document.getElementById('defenseAmount').textContent = game.player.defense;
            document.getElementById('goldAmount').textContent = game.gold;
            document.getElementById('breadCount').textContent = game.inventory.bread;
            document.getElementById('oreCount').textContent = game.inventory.ore;
            document.getElementById('gemsCount').textContent = game.inventory.gems;
            document.getElementById('herbsCount').textContent = game.inventory.herbs;
            document.getElementById('keyStatus').textContent = game.hasKey ? 'YES' : 'NO';
        }

        function getCurrentRoom() {
            const px = game.player.x;
            const pz = game.player.z;
            if (pz <= 4 && px <= 4) return 0;
            if (pz <= 4 && px >= 6) return 1;
            if (pz >= 7 && pz <= 9 && px <= 4) return 2;
            if (pz >= 7 && pz <= 9 && px >= 6) return 3;
            if (pz >= 11) return 4;
            return -1;
        }

        function turnLeft() {
            game.player.dir = (game.player.dir + 3) % 4;
            render();
            setMessage('YOU TURN LEFT.');
        }

        function turnRight() {
            game.player.dir = (game.player.dir + 1) % 4;
            render();
            setMessage('YOU TURN RIGHT.');
        }

        function moveForward() {
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            const [dx, dz] = dirs[game.player.dir];
            const newX = game.player.x + dx;
            const newZ = game.player.z + dz;

            if (newZ >= 0 && newZ < MAP_SIZE && newX >= 0 && newX < MAP_SIZE) {
                const currentMap = getCurrentMap();
                if (currentMap[newZ][newX] !== CELL_WALL) {
                    game.player.x = newX;
                    game.player.z = newZ;
                    
                    // Check for stairs
                    if (currentMap[newZ][newX] === CELL_STAIRS_DOWN) {
                        handleStairsDown();
                        return;
                    } else if (currentMap[newZ][newX] === CELL_STAIRS_UP) {
                        handleStairsUp();
                        return;
                    }
                    
                    moveBats();
                    checkBatEncounter();
                    render();
                    
                    const merchant = merchants.find(m => m.x === newX && m.z === newZ && m.level === game.currentLevel);
                    if (merchant) {
                        setMessage(`FOUND ${merchant.name}!<br>PRESS E TO TRADE.`);
                    } else {
                        const room = getCurrentRoom();
                        if (room >= 0) {
                            setMessage(`ENTERED ${roomColors[room].name}.`);
                        } else {
                            setMessage('YOU MOVE FORWARD.');
                        }
                    }
                } else {
                    setMessage('A WALL BLOCKS YOUR PATH!');
                }
            } else {
                setMessage('YOU CANNOT GO THAT WAY!');
            }
        }

        function moveBackward() {
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            const [dx, dz] = dirs[game.player.dir];
            const newX = game.player.x - dx;
            const newZ = game.player.z - dz;

            if (newZ >= 0 && newZ < MAP_SIZE && newX >= 0 && newX < MAP_SIZE) {
                const currentMap = getCurrentMap();
                if (currentMap[newZ][newX] !== CELL_WALL) {
                    game.player.x = newX;
                    game.player.z = newZ;
                    render();
                    setMessage('YOU MOVE BACKWARD.');
                } else {
                    setMessage('A WALL BLOCKS YOUR PATH!');
                }
            } else {
                setMessage('YOU CANNOT GO THAT WAY!');
            }
        }

        function handleStairsDown() {
            if (game.currentLevel < 3) {
                game.currentLevel++;
                game.player.x = 1;
                game.player.z = 1;
                game.player.dir = 0;
                render();
                setMessage(`‚¨áÔ∏è DESCENDED TO LEVEL ${game.currentLevel}!<br>DANGER INCREASES... PRICES IMPROVE!`);
            } else {
                setMessage('NO STAIRS HERE!');
            }
        }
        
        function handleStairsUp() {
            if (game.currentLevel > 1) {
                game.currentLevel--;
                game.player.x = 11;
                game.player.z = 8;
                game.player.dir = 2;
                render();
                setMessage(`‚¨ÜÔ∏è CLIMBED TO LEVEL ${game.currentLevel}.`);
            } else {
                setMessage('NO STAIRS HERE!');
            }
        }

        function checkBatEncounter() {
            const currentBats = getCurrentBats();
            for (let bat of currentBats) {
                if (bat.x === game.player.x && bat.z === game.player.z && bat.health > 0) {
                    if (bat.attacking) {
                        // Bat deals HEALTH DAMAGE based on level!
                        const baseDamage = 5 + (game.currentLevel * 3);
                        const actualDamage = Math.max(1, baseDamage - game.player.defense);
                        game.player.health -= actualDamage;
                        
                        // Bat steals 20% of gold (minimum 20 gold)
                        const goldStolen = Math.max(20, Math.floor(game.gold * 0.20));
                        const actualGoldStolen = Math.min(goldStolen, game.gold); // Can't steal more than you have
                        game.gold -= actualGoldStolen;
                        
                        // Bat also steals 1 random item if you have any
                        const items = ['bread', 'ore', 'gems', 'herbs'];
                        const availableItems = items.filter(item => game.inventory[item] > 0);
                        let stolenItem = null;
                        
                        if (availableItems.length > 0) {
                            stolenItem = availableItems[Math.floor(Math.random() * availableItems.length)];
                            game.inventory[stolenItem]--;
                        }
                        
                        updateUI();
                        
                        // CHECK IF PLAYER DIED!
                        if (game.player.health <= 0) {
                            setMessage('üíÄ YOU DIED! THE BATS HAVE DEFEATED YOU! üíÄ');
                            setTimeout(() => {
                                alert('GAME OVER! YOU DIED!');
                                location.reload();
                            }, 2000);
                            return;
                        }
                        
                        // Message about what was stolen
                        let message = 'ü¶á BAT ATTACK! ü¶á<br>';
                        message += `YOU TAKE ${actualDamage} DAMAGE! (HP: ${game.player.health}/${game.player.maxHealth})<br>`;
                        message += `THE BAT STEALS ${actualGoldStolen} GOLD!`;
                        if (stolenItem) {
                            message += `<br>AND YOUR ${itemNames[stolenItem].toUpperCase()}!`;
                        }
                        message += '<br>IT FLIES AWAY INTO THE DARKNESS!';
                        
                        // Check if player is broke or low health
                        if (game.gold < 10) {
                            message += '<br><br>‚ö†Ô∏è LOW FUNDS! FIND ITEMS TO SELL!';
                        }
                        if (game.player.health < 30) {
                            message += '<br><br>‚ö†Ô∏è LOW HEALTH! FIND HEALING!';
                        }
                        
                        setMessage(message);
                        
                        // Bat flees after attacking
                        bat.attacking = false;
                        const fleeDir = Math.floor(Math.random() * 4);
                        const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
                        const [dx, dz] = dirs[fleeDir];
                        const newX = bat.x + dx * 2;
                        const newZ = bat.z + dz * 2;
                        
                        if (newZ >= 0 && newZ < MAP_SIZE && newX >= 0 && newX < MAP_SIZE) {
                            const currentMap = getCurrentMap();
                            if (currentMap[newZ][newX] !== CELL_WALL) {
                                bat.x = newX;
                                bat.z = newZ;
                            }
                        }
                    }
                }
            }
        }

        
        function moveBats() {
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            const currentBats = getCurrentBats();
            const currentMap = getCurrentMap();
            
            for (let bat of currentBats) {
                if (bat.health <= 0) continue; // Skip dead bats
                
                bat.moveTimer++;
                
                // Move every 2 player moves (faster/more aggressive)
                if (bat.moveTimer >= 2) {
                    bat.moveTimer = 0;
                    
                    // Chase the player! Calculate direction to player
                    const dx = game.player.x - bat.x;
                    const dz = game.player.z - bat.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // If close to player, move toward them
                    if (distance < 6) {
                        // Determine best direction to move toward player
                        if (Math.abs(dx) > Math.abs(dz)) {
                            bat.dir = dx > 0 ? 1 : 3; // East or West
                        } else {
                            bat.dir = dz > 0 ? 2 : 0; // South or North
                        }
                    } else {
                        // Random wandering when far from player
                        if (Math.random() < 0.4) {
                            bat.dir = Math.floor(Math.random() * 4);
                        }
                    }
                    
                    const [bdx, bdz] = dirs[bat.dir];
                    const newX = bat.x + bdx;
                    const newZ = bat.z + bdz;
                    
                    // Move if valid
                    if (newZ >= 0 && newZ < MAP_SIZE && newX >= 0 && newX < MAP_SIZE) {
                        if (currentMap[newZ][newX] !== CELL_WALL) {
                            bat.x = newX;
                            bat.z = newZ;
                            
                            // Check if bat reached player
                            if (bat.x === game.player.x && bat.z === game.player.z) {
                                bat.attacking = true;
                            }
                        } else {
                            // Hit wall, turn around
                            bat.dir = (bat.dir + 2) % 4;
                        }
                    }
                }
            }
        }

        function interact() {
            for (let m of merchants) {
                if (m.x === game.player.x && m.z === game.player.z && m.level === game.currentLevel) {
                    openTrade(m);
                    return;
                }
            }

            const currentMap = getCurrentMap();
            if (currentMap[game.player.z][game.player.x] === CELL_DOOR) {
                if (game.hasKey) {
                    game.gameWon = true;
                    document.getElementById('finalGold').textContent = game.gold;
                    document.getElementById('victoryScreen').classList.add('active');
                } else {
                    setMessage('THE DOOR IS LOCKED!<br>YOU NEED THE ESCAPE KEY.<br>BUY IT FROM KEY SELLER FOR 500 GOLD.');
                }
                return;
            }

            setMessage('NOTHING HERE TO INTERACT WITH.');
        }

        function rest() {
            setMessage('YOU REST FOR A MOMENT.<br>THE DUNGEON IS QUIET...');
        }

        function openTrade(merchant) {
            currentMerchant = merchant;
            document.getElementById('merchantTitle').textContent = merchant.name;
            document.getElementById('merchantSubtitle').textContent = roomColors[merchant.room].name;
            
            const itemList = document.getElementById('itemList');
            itemList.innerHTML = '';

            // BLACKSMITH - Show equipment upgrades!
            if (merchant.isBlacksmith) {
                itemList.innerHTML = '<div style="color: #FFFF55; margin-bottom: 10px; text-align: center; font-size: 16px;">‚öíÔ∏è EQUIPMENT UPGRADES ‚öíÔ∏è</div>';
                
                Object.entries(merchant.upgrades).forEach(([name, upgrade]) => {
                    const currentUpgrade = upgrade.type === 'weapon' ? game.upgrades.weapon : game.upgrades.armor;
                    const canBuy = currentUpgrade < upgrade.level;
                    
                    const div = document.createElement('div');
                    div.className = 'item-row';
                    if (!canBuy) div.style.opacity = '0.5';
                    div.innerHTML = `
                        <div class="item-name">${name}</div>
                        <div class="item-info">${upgrade.desc}<br>${canBuy ? `COST: ${upgrade.cost} GOLD` : 'ALREADY OWNED/HIGHER'}</div>
                        <button class="btn" onclick="buyUpgrade('${name}')" ${!canBuy ? 'disabled' : ''} style="grid-column: 1 / -1;">
                            ${canBuy ? `BUY ${upgrade.cost}G` : 'N/A'}
                        </button>
                    `;
                    itemList.appendChild(div);
                });
            } else {
                // NORMAL MERCHANT - Show items
                Object.entries(merchant.prices).forEach(([item, data]) => {
                    const div = document.createElement('div');
                    div.className = 'item-row';
                    div.innerHTML = `
                        <div class="item-name">${itemNames[item]}</div>
                        <div class="item-info">${data.reason}<br>YOU HAVE: ${game.inventory[item]}</div>
                        <div class="item-actions">
                            <button class="btn" onclick="buyItem('${item}')">BUY ${data.buy}G</button>
                            <button class="btn" onclick="sellItem('${item}')">SELL ${data.sell}G</button>
                        </div>
                    `;
                    itemList.appendChild(div);
                });

                // ESCAPE KEY (only for merchants who sell it)
                if (merchant.sellsKey) {
                    const keyDiv = document.createElement('div');
                    keyDiv.className = 'item-row';
                    keyDiv.style.border = '3px solid #FFFF55';
                    keyDiv.innerHTML = `
                        <div class="item-name">‚òÖ ESCAPE KEY ‚òÖ</div>
                        <div class="item-info">UNLOCKS THE EXIT DOOR<br>YOU NEED: ${merchant.keyPrice} GOLD | YOU HAVE: ${game.gold} GOLD</div>
                        <button class="btn" onclick="buyKey()" ${game.hasKey ? 'disabled' : ''} style="grid-column: 1 / -1;">
                            ${game.hasKey ? 'ALREADY PURCHASED' : `BUY ${merchant.keyPrice}G`}
                        </button>
                    `;
                    itemList.appendChild(keyDiv);
                }
                
                // HEALING (for healers)
                if (merchant.healsFor) {
                    const healDiv = document.createElement('div');
                    healDiv.className = 'item-row';
                    healDiv.style.border = '2px solid #00FF00';
                    healDiv.innerHTML = `
                        <div class="item-name">üíö HEALING üíö</div>
                        <div class="item-info">RESTORE ${merchant.healsFor} HP<br>CURRENT HP: ${game.player.health}/${game.player.maxHealth}</div>
                        <button class="btn" onclick="buyHealing()" ${game.player.health >= game.player.maxHealth ? 'disabled' : ''} style="grid-column: 1 / -1;">
                            ${game.player.health >= game.player.maxHealth ? 'FULL HEALTH' : `HEAL ${merchant.healCost}G`}
                        </button>
                    `;
                    itemList.appendChild(healDiv);
                }
            }

            document.getElementById('tradingMenu').classList.add('active');
        }

        function closeTrade() {
            document.getElementById('tradingMenu').classList.remove('active');
            currentMerchant = null;
        }

        function buyItem(item) {
            const price = currentMerchant.prices[item].buy;
            if (game.gold >= price) {
                game.gold -= price;
                game.inventory[item]++;
                updateUI();
                setMessage(`PURCHASED ${itemNames[item]} FOR ${price} GOLD.`);
                openTrade(currentMerchant);
            } else {
                setMessage('NOT ENOUGH GOLD!');
            }
        }

        function sellItem(item) {
            if (game.inventory[item] > 0) {
                const price = currentMerchant.prices[item].sell;
                game.gold += price;
                game.inventory[item]--;
                updateUI();
                setMessage(`SOLD ${itemNames[item]} FOR ${price} GOLD.`);
                openTrade(currentMerchant);
            } else {
                setMessage(`YOU DON'T HAVE ANY ${itemNames[item]}!`);
            }
        }

        function buyKey() {
            if (game.gold >= 500) {
                game.gold -= 500;
                game.hasKey = true;
                updateUI();
                setMessage('PURCHASED ESCAPE KEY!<br>HEAD TO THE EXIT CHAMBER!');
                closeTrade();
            } else {
                setMessage(`NOT ENOUGH GOLD!<br>YOU HAVE ${game.gold}. NEED 500.`);
            }
        }

        function buyUpgrade(upgradeName) {
            const upgrade = currentMerchant.upgrades[upgradeName];
            if (game.gold >= upgrade.cost) {
                game.gold -= upgrade.cost;
                
                if (upgrade.type === 'weapon') {
                    game.upgrades.weapon = upgrade.level;
                    game.player.attack = 5 + upgrade.attack;
                    setMessage(`PURCHASED ${upgradeName}!<br>ATTACK: ${game.player.attack}`);
                } else {
                    game.upgrades.armor = upgrade.level;
                    game.player.defense = upgrade.defense;
                    setMessage(`PURCHASED ${upgradeName}!<br>DEFENSE: ${game.player.defense}`);
                }
                
                updateUI();
                openTrade(currentMerchant);
            } else {
                setMessage('NOT ENOUGH GOLD!');
            }
        }
        
        function buyHealing() {
            if (game.gold >= currentMerchant.healCost) {
                game.gold -= currentMerchant.healCost;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + currentMerchant.healsFor);
                setMessage(`HEALED ${currentMerchant.healsFor} HP!<br>HP: ${game.player.health}/${game.player.maxHealth}`);
                updateUI();
                openTrade(currentMerchant);
            } else {
                setMessage('NOT ENOUGH GOLD!');
            }
        }

        function isWall(x, z) {
            if (x < 0 || x >= MAP_SIZE || z < 0 || z >= MAP_SIZE) return true;
            const currentMap = getCurrentMap();
            return currentMap[z][x] === CELL_WALL;
        }

        function isDoor(x, z) {
            if (x < 0 || x >= MAP_SIZE || z < 0 || z >= MAP_SIZE) return false;
            const currentMap = getCurrentMap();
            return currentMap[z][x] === CELL_DOOR;
        }
        
        function isStairs(x, z) {
            if (x < 0 || x >= MAP_SIZE || z < 0 || z >= MAP_SIZE) return false;
            const currentMap = getCurrentMap();
            return currentMap[z][x] === CELL_STAIRS_DOWN || currentMap[z][x] === CELL_STAIRS_UP;
        }

        function isMerchant(x, z) {
            return merchants.some(m => m.x === x && m.z === z && m.level === game.currentLevel);
        }

        function isBat(x, z) {
            const currentBats = getCurrentBats();
            return currentBats.some(b => b.x === x && b.z === z && b.health > 0);
        }

        function adjustBrightness(color, factor) {
            const hex = color.replace('#', '');
            const r = Math.floor(parseInt(hex.substr(0, 2), 16) * factor);
            const g = Math.floor(parseInt(hex.substr(2, 2), 16) * factor);
            const b = Math.floor(parseInt(hex.substr(4, 2), 16) * factor);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function drawBrickWall(x, y, w, h, color, brightness) {
            ctx.fillStyle = adjustBrightness(color, brightness);
            ctx.fillRect(x, y, w, h);
            
            ctx.strokeStyle = adjustBrightness('#000000', brightness * 0.5);
            ctx.lineWidth = 2;
            
            const brickW = 40;
            const brickH = 20;
            
            for (let row = 0; row < h / brickH; row++) {
                for (let col = 0; col < w / brickW; col++) {
                    const bx = x + col * brickW + (row % 2) * (brickW / 2);
                    const by = y + row * brickH;
                    
                    if (bx < x + w) {
                        ctx.strokeRect(bx, by, Math.min(brickW, x + w - bx), brickH);
                    }
                }
            }
            
            ctx.fillStyle = adjustBrightness(color, brightness * 0.7);
            for (let i = 0; i < 5; i++) {
                const bx = x + (Math.floor(Math.random() * (w / brickW)) * brickW);
                const by = y + (Math.floor(Math.random() * (h / brickH)) * brickH);
                ctx.fillRect(bx + 2, by + 2, brickW - 4, brickH - 4);
            }
        }

        function drawStore(x, y, w, h, wallColor) {
            // Draw as pixel art style with dithering and shading
            
            // Stone wall background with texture
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(x, y, w, h);
            
            // Add stone texture with dithering
            ctx.fillStyle = '#6B5345';
            for (let py = y; py < y + h; py += 4) {
                for (let px = x; px < x + w; px += 4) {
                    if ((px + py) % 8 === 0) {
                        ctx.fillRect(px, py, 2, 2);
                    }
                }
            }
            
            // Wooden merchant stall frame
            ctx.fillStyle = '#4A3520';
            ctx.fillRect(x + 50, y + 40, 20, h - 80);  // Left post
            ctx.fillRect(x + w - 70, y + 40, 20, h - 80); // Right post
            ctx.fillRect(x + 50, y + 40, w - 100, 25); // Top beam
            
            // Wood grain
            ctx.strokeStyle = '#3A2510';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 50, y + 45 + i * 4);
                ctx.lineTo(x + w - 70, y + 45 + i * 4);
                ctx.stroke();
            }
            
            // Fabric awning - red with shading
            const awningHeight = 50;
            for (let i = 0; i < awningHeight; i++) {
                const shade = 200 - i * 2;
                ctx.fillStyle = `rgb(${shade}, 0, 0)`;
                ctx.fillRect(x + 70, y + 10 + i, w - 140, 1);
            }
            
            // Awning support ropes
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 70, y + 40);
            ctx.lineTo(x + 50, y + 40);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + w - 70, y + 40);
            ctx.lineTo(x + w - 50, y + 40);
            ctx.stroke();
            
            // Counter with depth and shading
            const counterTop = y + h - 130;
            ctx.fillStyle = '#654321';
            ctx.fillRect(x + 80, counterTop, w - 160, 15);
            
            // Counter front with shading
            for (let i = 0; i < 50; i++) {
                const shade = 80 - i;
                ctx.fillStyle = `rgb(${shade}, ${Math.floor(shade * 0.6)}, ${Math.floor(shade * 0.3)})`;
                ctx.fillRect(x + 80, counterTop + 15 + i, w - 160, 1);
            }
            
            // Goods on counter - pixel art style
            
            // Stack of bread loaves
            for (let i = 0; i < 3; i++) {
                const breadY = counterTop - 10 - i * 15;
                // Bread outline
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x + 120, breadY, 50, 18);
                // Bread highlight
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(x + 125, breadY + 3, 40, 10);
                // Bread detail
                ctx.fillStyle = '#8B4513';
                for (let d = 0; d < 3; d++) {
                    ctx.fillRect(x + 130 + d * 12, breadY + 6, 8, 2);
                }
            }
            
            // Gem pile - pixel art crystals
            const gemX = x + 280;
            const gemY = counterTop - 15;
            
            // Purple gem
            ctx.fillStyle = '#8B008B';
            ctx.fillRect(gemX, gemY, 12, 4);
            ctx.fillRect(gemX + 2, gemY - 4, 8, 4);
            ctx.fillRect(gemX + 4, gemY - 8, 4, 4);
            ctx.fillStyle = '#FF00FF';
            ctx.fillRect(gemX + 5, gemY - 6, 2, 2);
            
            // Blue gem  
            ctx.fillStyle = '#000080';
            ctx.fillRect(gemX + 15, gemY + 5, 12, 4);
            ctx.fillRect(gemX + 17, gemY + 1, 8, 4);
            ctx.fillRect(gemX + 19, gemY - 3, 4, 4);
            ctx.fillStyle = '#0000FF';
            ctx.fillRect(gemX + 20, gemY - 1, 2, 2);
            
            // Red gem
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(gemX + 30, gemY + 2, 12, 4);
            ctx.fillRect(gemX + 32, gemY - 2, 8, 4);
            ctx.fillRect(gemX + 34, gemY - 6, 4, 4);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(gemX + 35, gemY - 4, 2, 2);
            
            // Herbs in wooden crate
            const herbX = x + 380;
            ctx.fillStyle = '#654321';
            ctx.fillRect(herbX, counterTop - 25, 45, 30);
            // Herb sprigs
            ctx.fillStyle = '#228B22';
            for (let h = 0; h < 5; h++) {
                const hx = herbX + 5 + h * 8;
                ctx.fillRect(hx, counterTop - 30, 3, 12);
                ctx.fillRect(hx - 2, counterTop - 32, 2, 2);
                ctx.fillRect(hx + 3, counterTop - 32, 2, 2);
                ctx.fillRect(hx - 2, counterTop - 28, 2, 2);
                ctx.fillRect(hx + 3, counterTop - 28, 2, 2);
            }
            
            // Ore chunks - gray with highlights
            const oreX = x + 470;
            ctx.fillStyle = '#696969';
            ctx.fillRect(oreX, counterTop - 20, 30, 25);
            ctx.fillRect(oreX + 20, counterTop - 28, 25, 20);
            ctx.fillStyle = '#A9A9A9';
            ctx.fillRect(oreX + 5, counterTop - 18, 8, 8);
            ctx.fillRect(oreX + 25, counterTop - 24, 6, 6);
            ctx.fillStyle = '#DCDCDC';
            ctx.fillRect(oreX + 7, counterTop - 16, 3, 3);
            ctx.fillRect(oreX + 27, counterTop - 22, 2, 2);
            
            // Merchant sprite - pixel art character
            const merchX = x + w / 2 - 20;
            const merchY = counterTop - 100;
            
            // Hat
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(merchX - 5, merchY, 50, 8);
            ctx.fillRect(merchX + 5, merchY - 10, 30, 10);
            
            // Head
            ctx.fillStyle = '#FFDAB9';
            ctx.fillRect(merchX + 8, merchY + 8, 24, 28);
            
            // Eyes
            ctx.fillStyle = '#000000';
            ctx.fillRect(merchX + 13, merchY + 16, 4, 4);
            ctx.fillRect(merchX + 23, merchY + 16, 4, 4);
            
            // Nose
            ctx.fillStyle = '#CD853F';
            ctx.fillRect(merchX + 18, merchY + 22, 4, 6);
            
            // Smile
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(merchX + 14, merchY + 30, 12, 2);
            
            // Beard
            ctx.fillStyle = '#696969';
            ctx.fillRect(merchX + 10, merchY + 32, 20, 8);
            for (let b = 0; b < 4; b++) {
                ctx.fillRect(merchX + 12 + b * 4, merchY + 40, 3, 4);
            }
            
            // Body - ONE PIECE brown robe (no separate parts!)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(merchX - 5, merchY + 40, 50, 50);
            
            // Robe shading on right side
            ctx.fillStyle = '#654321';
            ctx.fillRect(merchX + 25, merchY + 40, 20, 50);
            
            // White apron over robe - covers everything
            ctx.fillStyle = '#F5F5DC';
            ctx.fillRect(merchX + 5, merchY + 45, 30, 45);
            
            // Apron tie at neck
            ctx.fillStyle = '#654321';
            ctx.fillRect(merchX + 15, merchY + 40, 10, 5);
            
            // Belt with buckle
            ctx.fillStyle = '#000000';
            ctx.fillRect(merchX - 5, merchY + 65, 50, 4);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(merchX + 16, merchY + 64, 8, 6);
            
            // Arms coming out from sides
            ctx.fillStyle = '#FFDAB9';
            ctx.fillRect(merchX - 10, merchY + 50, 8, 20);
            ctx.fillRect(merchX + 42, merchY + 50, 8, 20);
            
            // Hands pointing at goods
            ctx.fillRect(merchX - 14, merchY + 70, 8, 8);
            ctx.fillRect(merchX + 46, merchY + 70, 8, 8);
            
            // Thick border for visibility
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 6;
            ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);
            
            // Text INSIDE the canvas, not below it
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('MERCHANT', x + w/2 + 2, y + h - 22);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText('MERCHANT', x + w/2, y + h - 24);
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 18px Courier New';
            ctx.fillText('PRESS E TO TRADE', x + w/2 + 2, y + h - 3);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('PRESS E TO TRADE', x + w/2, y + h - 5);
        }

        function render() {
            const p = game.player;
            const room = getCurrentRoom();
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const roomColor = room >= 0 ? roomColors[room] : { wall: '#555555', floor: '#333333' };

            // Ceiling
            const ceilingGradient = ctx.createLinearGradient(0, 0, 0, 200);
            ceilingGradient.addColorStop(0, '#000000');
            ceilingGradient.addColorStop(1, adjustBrightness(roomColor.wall, 0.3));
            ctx.fillStyle = ceilingGradient;
            ctx.fillRect(0, 0, 800, 200);

            // Floor
            const floorGradient = ctx.createLinearGradient(0, 200, 0, 400);
            floorGradient.addColorStop(0, adjustBrightness(roomColor.floor, 0.6));
            floorGradient.addColorStop(1, adjustBrightness(roomColor.floor, 1.0));
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, 200, 800, 200);
            
            // Floor grid
            ctx.strokeStyle = adjustBrightness(roomColor.floor, 0.4);
            ctx.lineWidth = 1;
            for (let i = 1; i < 5; i++) {
                const y = 200 + i * 40;
                ctx.beginPath();
                ctx.moveTo(100 - i * 10, y);
                ctx.lineTo(700 + i * 10, y);
                ctx.stroke();
            }

            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            const [dx, dz] = dirs[p.dir];
            
            const walls = [];
            for (let depth = 1; depth <= 3; depth++) {
                const x = p.x + dx * depth;
                const z = p.z + dz * depth;
                const leftX = p.x + dirs[(p.dir + 3) % 4][0] * depth + dx * (depth - 1);
                const leftZ = p.z + dirs[(p.dir + 3) % 4][1] * depth + dz * (depth - 1);
                const rightX = p.x + dirs[(p.dir + 1) % 4][0] * depth + dx * (depth - 1);
                const rightZ = p.z + dirs[(p.dir + 1) % 4][1] * depth + dz * (depth - 1);
                
                walls.push({
                    depth: depth,
                    front: isWall(x, z),
                    left: isWall(leftX, leftZ),
                    right: isWall(rightX, rightZ),
                    door: isDoor(x, z),
                    merchant: isMerchant(x, z),
                    bat: isBat(x, z),
                    stairs: isStairs(x, z)
                });
            }
            
            // IMPORTANT: Check if player is standing ON a merchant
            const playerOnMerchant = isMerchant(p.x, p.z);
            if (playerOnMerchant) {
                // Override - show merchant as if they're in front
                walls[0].front = true;
                walls[0].merchant = true;
                walls[0].door = false;
                walls[0].bat = false;
            }
            
            // Check if player is ON a bat
            const playerOnBat = isBat(p.x, p.z);
            if (playerOnBat) {
                walls[0].front = true;
                walls[0].bat = true;
                walls[0].merchant = false;
                walls[0].door = false;
            }

            // Depth 3
            if (walls[2].left) {
                drawBrickWall(200, 100, 50, 150, roomColor.wall, 0.5);
            }
            
            if (walls[2].right) {
                drawBrickWall(550, 100, 50, 150, roomColor.wall, 0.5);
            }
            
            if (walls[2].front) {
                drawBrickWall(250, 100, 300, 100, roomColor.wall, 0.6);
            }

            // Depth 2
            if (walls[1].left) {
                ctx.fillStyle = adjustBrightness(roomColor.wall, 0.7);
                ctx.beginPath();
                ctx.moveTo(100, 75);
                ctx.lineTo(200, 75);
                ctx.lineTo(200, 250);
                ctx.lineTo(100, 300);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = adjustBrightness('#000000', 0.4);
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    ctx.moveTo(100 + i * 15, 75 + i * 28);
                    ctx.lineTo(200, 75 + i * 25);
                    ctx.stroke();
                }
            }
            
            if (walls[1].right) {
                ctx.fillStyle = adjustBrightness(roomColor.wall, 0.7);
                ctx.beginPath();
                ctx.moveTo(600, 75);
                ctx.lineTo(700, 75);
                ctx.lineTo(700, 300);
                ctx.lineTo(600, 250);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = adjustBrightness('#000000', 0.4);
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    ctx.moveTo(600, 75 + i * 25);
                    ctx.lineTo(700 - i * 15, 75 + i * 28);
                    ctx.stroke();
                }
            }
            
            if (walls[1].front) {
                drawBrickWall(200, 75, 400, 175, roomColor.wall, 0.75);
            }

            // Depth 1
            if (walls[0].left) {
                ctx.fillStyle = adjustBrightness(roomColor.wall, 0.85);
                ctx.beginPath();
                ctx.moveTo(0, 50);
                ctx.lineTo(100, 50);
                ctx.lineTo(100, 350);
                ctx.lineTo(0, 400);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = adjustBrightness('#000000', 0.5);
                ctx.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, 50 + i * 30);
                    ctx.lineTo(100, 50 + i * 25);
                    ctx.stroke();
                }
            }
            
            if (walls[0].right) {
                ctx.fillStyle = adjustBrightness(roomColor.wall, 0.85);
                ctx.beginPath();
                ctx.moveTo(700, 50);
                ctx.lineTo(800, 50);
                ctx.lineTo(800, 400);
                ctx.lineTo(700, 350);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = adjustBrightness('#000000', 0.5);
                ctx.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    ctx.beginPath();
                    ctx.moveTo(700, 50 + i * 25);
                    ctx.lineTo(800, 50 + i * 30);
                    ctx.stroke();
                }
            }
            
            if (!walls[0].front) {
                ctx.fillStyle = adjustBrightness(roomColor.floor, 0.5);
                ctx.fillRect(100, 50, 600, 300);
            } else {
                if (walls[0].bat) {
                    drawBrickWall(100, 50, 600, 300, roomColor.wall, 0.9);
                    
                    // Check if bat is attacking for animation
                    const attackingBat = bats.find(b => b.x === p.x + dx && b.z === p.z + dz);
                    const isAttacking = attackingBat && attackingBat.attacking;
                    
                    // Red warning aura if attacking
                    if (isAttacking) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(100, 50, 600, 300);
                    }
                    
                    // Bat sprite - PIXEL ART STYLE
                    const batX = 400;
                    const batY = 180;
                    
                    // Body - dark purple pixelated
                    ctx.fillStyle = '#4B0082';
                    ctx.fillRect(batX - 15, batY, 30, 12);
                    ctx.fillRect(batX - 12, batY - 8, 24, 8);
                    ctx.fillRect(batX - 8, batY - 12, 16, 4);
                    
                    // Ears/horns - pixel style
                    ctx.fillRect(batX - 10, batY - 16, 4, 4);
                    ctx.fillRect(batX + 6, batY - 16, 4, 4);
                    
                    // Wings - pixelated
                    ctx.fillStyle = '#8B008B';
                    
                    // Left wing
                    ctx.fillRect(batX - 50, batY + 5, 15, 8);
                    ctx.fillRect(batX - 40, batY, 15, 10);
                    ctx.fillRect(batX - 30, batY - 5, 15, 12);
                    ctx.fillRect(batX - 55, batY + 10, 10, 5);
                    ctx.fillRect(batX - 45, batY + 13, 10, 3);
                    
                    // Wing membrane details
                    ctx.fillStyle = '#6A0080';
                    ctx.fillRect(batX - 48, batY + 7, 3, 4);
                    ctx.fillRect(batX - 38, batY + 3, 3, 5);
                    ctx.fillRect(batX - 28, batY - 2, 3, 6);
                    
                    // Right wing
                    ctx.fillStyle = '#8B008B';
                    ctx.fillRect(batX + 35, batY + 5, 15, 8);
                    ctx.fillRect(batX + 25, batY, 15, 10);
                    ctx.fillRect(batX + 15, batY - 5, 15, 12);
                    ctx.fillRect(batX + 45, batY + 10, 10, 5);
                    ctx.fillRect(batX + 35, batY + 13, 10, 3);
                    
                    // Wing membrane details
                    ctx.fillStyle = '#6A0080';
                    ctx.fillRect(batX + 45, batY + 7, 3, 4);
                    ctx.fillRect(batX + 35, batY + 3, 3, 5);
                    ctx.fillRect(batX + 25, batY - 2, 3, 6);
                    
                    // Eyes - glowing red pixels
                    ctx.fillStyle = '#FF0000';
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(batX - 8, batY - 6, 4, 6);
                    ctx.fillRect(batX + 4, batY - 6, 4, 6);
                    ctx.shadowBlur = 0;
                    
                    // Eye gleam
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(batX - 7, batY - 5, 2, 2);
                    ctx.fillRect(batX + 5, batY - 5, 2, 2);
                    
                    // Fangs - white pixels
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(batX - 6, batY + 6, 3, 4);
                    ctx.fillRect(batX + 3, batY + 6, 3, 4);
                    
                    // Outline for definition
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(batX - 15, batY, 30, 12);
                    
                    // Motion lines if attacking
                    if (isAttacking) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 8; i++) {
                            const offset = i * 15;
                            // Left side motion
                            ctx.beginPath();
                            ctx.moveTo(batX - 80 - offset, batY - 20 + i * 5);
                            ctx.lineTo(batX - 60 - offset, batY - 15 + i * 5);
                            ctx.stroke();
                            
                            // Right side motion  
                            ctx.beginPath();
                            ctx.moveTo(batX + 80 + offset, batY - 20 + i * 5);
                            ctx.lineTo(batX + 60 + offset, batY - 15 + i * 5);
                            ctx.stroke();
                        }
                    }
                    
                    // Border
                    ctx.strokeStyle = isAttacking ? '#FF0000' : '#8B008B';
                    ctx.lineWidth = 6;
                    ctx.strokeRect(100, 50, 600, 300);
                    
                    // Text with pixel font feel
                    ctx.font = 'bold 32px Courier New';
                    ctx.fillStyle = '#000000';
                    ctx.fillText(isAttacking ? '!!! BAT ATTACK !!!' : 'BAT AHEAD!', 
                                isAttacking ? 272 : 312, 367);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillText(isAttacking ? '!!! BAT ATTACK !!!' : 'BAT AHEAD!', 
                                isAttacking ? 270 : 310, 365);
                    
                    ctx.font = 'bold 20px Courier New';
                    ctx.fillStyle = '#000000';
                    ctx.fillText('IT\'S HUNTING YOU!', 282, 392);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText('IT\'S HUNTING YOU!', 280, 390);
                    
                } else if (walls[0].door) {
                    drawBrickWall(100, 50, 600, 300, roomColor.wall, 0.9);
                    
                    const doorColor = game.hasKey ? '#00AA00' : '#AA0000';
                    ctx.fillStyle = doorColor;
                    ctx.fillRect(250, 75, 300, 250);
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 6;
                    ctx.strokeRect(250, 75, 300, 250);
                    
                    ctx.strokeStyle = adjustBrightness(doorColor, 0.6);
                    ctx.lineWidth = 4;
                    ctx.strokeRect(270, 95, 130, 100);
                    ctx.strokeRect(420, 95, 110, 100);
                    ctx.strokeRect(270, 210, 130, 100);
                    ctx.strokeRect(420, 210, 110, 100);
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(500, 200, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(495, 210, 10, 20);
                    
                    ctx.font = 'bold 24px Courier New';
                    ctx.fillStyle = game.hasKey ? '#00FF00' : '#FF0000';
                    ctx.fillText('EXIT DOOR', 320, 360);
                    if (!game.hasKey) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText('LOCKED - NEED KEY', 260, 385);
                    }
                    
                } else if (walls[0].stairs) {
                    // Draw stairs!
                    drawBrickWall(100, 50, 600, 300, roomColor.wall, 0.8);
                    
                    // Determine if up or down stairs
                    const currentMap = getCurrentMap();
                    const stairsType = currentMap[game.player.z + dirs[p.dir][1]][game.player.x + dirs[p.dir][0]];
                    
                    if (stairsType === CELL_STAIRS_DOWN) {
                        ctx.fillStyle = '#FFFF55';
                        ctx.font = 'bold 120px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚¨á', 400, 250);
                        ctx.font = '30px monospace';
                        ctx.fillText('STAIRS DOWN', 400, 310);
                    } else {
                        ctx.fillStyle = '#FFFF55';
                        ctx.font = 'bold 120px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚¨Ü', 400, 250);
                        ctx.font = '30px monospace';
                        ctx.fillText('STAIRS UP', 400, 310);
                    }
                    
                } else if (walls[0].merchant) {
                    drawStore(100, 50, 600, 300, roomColor.wall);
                    
                } else {
                    drawBrickWall(100, 50, 600, 300, roomColor.wall, 1.0);
                }
            }

            drawMinimap();
        }

        function drawMinimap() {
            const ctx = minimapCtx;
            const cellSize = 9;
            const currentMap = getCurrentMap();
            const currentBats = getCurrentBats();
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 120, 120);
            
            for (let z = 0; z < MAP_SIZE; z++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (currentMap[z][x] === CELL_WALL) {
                        ctx.fillStyle = '#AAAAFF';
                    } else if (currentMap[z][x] === CELL_DOOR) {
                        ctx.fillStyle = game.hasKey ? '#00FF00' : '#FF0000';
                    } else if (currentMap[z][x] === CELL_STAIRS_DOWN) {
                        ctx.fillStyle = '#FFD700'; // Gold for down stairs
                    } else if (currentMap[z][x] === CELL_STAIRS_UP) {
                        ctx.fillStyle = '#FFA500'; // Orange for up stairs
                    } else if (currentMap[z][x] === CELL_MERCHANT) {
                        ctx.fillStyle = '#FFFF55';
                    } else {
                        ctx.fillStyle = '#333333';
                    }
                    ctx.fillRect(x * cellSize, z * cellSize, cellSize - 1, cellSize - 1);
                }
            }
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(game.player.x * cellSize + 2, game.player.z * cellSize + 2, cellSize - 4, cellSize - 4);
            
            ctx.fillStyle = '#8B008B';
            for (let bat of currentBats) {
                if (bat.health > 0) {
                    ctx.fillRect(bat.x * cellSize + 3, bat.z * cellSize + 3, cellSize - 6, cellSize - 6);
                }
            }
            
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            const [dx, dz] = dirs[game.player.dir];
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(game.player.x * cellSize + 4, game.player.z * cellSize + 4);
            ctx.lineTo((game.player.x + dx * 0.5) * cellSize + 4, (game.player.z + dz * 0.5) * cellSize + 4);
            ctx.stroke();
        }

        window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    moveForward();
                    break;
                case 's':
                case 'arrowdown':
                    moveBackward();
                    break;
                case 'a':
                case 'arrowleft':
                    turnLeft();
                    break;
                case 'd':
                case 'arrowright':
                    turnRight();
                    break;
                case 'e':
                case ' ':
                    interact();
                    break;
            }
        });

        updateUI();
        render();
    </script>
</body>
</html>
